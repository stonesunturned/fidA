# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/PRESS.ppg"
;****************************************************************
;
; Copyright (c) 2002-2003
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; All Rights Reserved
;
; PRESS.ppg - voxel selective spectroscopy  method
;
;****************************************************************

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/MRI.include" 1
;****************************************************************
;
; $Source: /pv/CvsTree/pv/gen/src/prg/methManag/PPG/MRI.include,v $
;
; Copyright (c) 2006
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; All Rights Reserved
;
;;****************************************************************
;MRI.include

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/Avance.incl" 1
;Avance3.incl
;   for AVi
;
;avance-version (07/01/22)
;
;$CLASS=HighRes Incl
;$COMMENT=












































































































































;$Id: Avance3.incl,v 1.3.2.4 2007/08/20 07:14:40 pfre Exp $
# 14 "/opt/PV5.1/exp/stan/nmr/lists/pp/MRI.include" 2


define delay aqq
define delay deparx
define delay derxadc
define delay rdepa

"aqq=dw*td"
"rdepa=de-depa"
"deparx=depa-derx"
"derxadc=derx-deadc"











































# 86 "/opt/PV5.1/exp/stan/nmr/lists/pp/MRI.include"






# 13 "/opt/PV5.1/exp/stan/nmr/lists/pp/PRESS.ppg" 2


# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 1
;****************************************************************
;
; Copyright (c) 2003-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: PrepModulesHead.mod,v 1.14.2.1 2007/07/02 13:05:36 mawi Exp $
;
; All Rights Reserved
;
; Declaration of pulseprogram parameters and subroutines for 
; preparation  modules
;
;****************************************************************

;**** Fat Suppression Module ****

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/FatSupDef.mod" 1
;****************************************************************
;
; Copyright (c) 2002-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: FatSupDef.mod,v 1.1.2.2 2007/07/02 14:26:25 mawi Exp $
;
; All Rights Reserved
;
; FatSupDef.mod : Declaration of Fat Suppression Subroutine
;
;****************************************************************

if(PVM_FatSupOnOff)
{
define list<frequency> modlis6 = {$PVM_FatSupFL}
define delay FsD0 = {$PVM_FsD0}
define delay FsD1 = {$PVM_FsD1}
define delay FsD2 = {$PVM_FsD2}

define pulse FsP0 = {$PVM_FsP0}
}

















# 18 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;**** Flow Saturation Module ****

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/FlowSatDef.mod" 1
;****************************************************************
;
; Copyright (c) 2005-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: FlowSatDef.mod,v 1.1.4.2 2007/07/02 13:26:58 mawi Exp $
;
; All Rights Reserved
;
; FlowSatDef.mod: Declaration of subroutines for Flow Saturation 
; call
; subr FlowSat()
; subr FlowSatInit()
; subr FlowSatInc()
; 
;****************************************************************

if(PVM_InFlowSatOnOff == 1)
   {
define list<frequency> modlis4 = {$PVM_InFlowSatFL}
define delay SfD0 = {$PVM_SfD0}
define delay SfD1 = {$PVM_SfD1}
define delay SfD2 = {$PVM_SfD2}

define pulse SfP0 = {$PVM_SfP0}

define loopcounter SfLp0 = {$PVM_SfLp0}
   }










































# 22 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;**** Inversion Pulse Module ****
# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/InvPulseDef.mod" 1
;****************************************************************
;
; Copyright (c) 2002-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: InvPulseDef.mod,v 1.1.2.2 2007/07/02 14:26:25 mawi Exp $
;
; All Rights Reserved
;
; InvPulseDef.mod : Declaration of Inversion Pulse subroutine
;
; call
; subr InvPulse()
;
;****************************************************************
;   
;       PVM_InvRFPulseArr      :  
;     
;       sp22            TPQQ[14].name : PVM_InvRFPulsePropertyArr[0].Filename
;
;       PVM_IpP0                      :  PVM_InvRFPulseArr[0].PulseLength
;
;       PVM_IpD2                      :  PVM_InvPulseDelay[0]
;       PVM_IpD3                      :  PVM_InvPulseSpoilTime[0]
;       PVM_IpD1                      :  CONFIG_amplifier _enable
;       PVM_IpD0                      :  PVM_RampTime
;

if(PVM_InvPulseOnOff == 1)
{
define list<frequency>  modlis2= {$PVM_InvPulseOffsetHz}
define delay IpD0 = {$PVM_IpD0}
define delay IpD1 = {$PVM_IpD1}
define delay IpD2 = {$PVM_IpD2}
define delay IpD3 = {$PVM_IpD3}

define pulse IpP0 = {$PVM_IpP0}
}




















# 25 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;**** Magnetisation Transfer Module ****

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/MagTransDef.mod" 1
;****************************************************************
; $Source: /pv/CvsTree/pv/gen/src/prg/methManag/PPG/MagTransDef.mod,v $
;
; Copyright (c) 2005-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; All Rights Reserved
;
; MagTransDef.mod: Declaration of subroutine for Magnetization 
;                  transfer 
; call
; subr MagTrans()
;
; $Id: MagTransDef.mod,v 1.1.2.3 2008/06/05 17:10:28 mawi Exp $
;****************************************************************
;**** Magnetisation Transfer Module ****


if(PVM_MagTransOnOff)
{
define list<frequency> modlis3 = {$PVM_MagTransFL} 
define delay MtD0 = {$PVM_MtD0}
define delay MtD1 = {$PVM_MtD1}
define delay MtD2 = {$PVM_MtD2}
define delay MtD3 = {$PVM_MtD3}

define pulse MtP0 = {$PVM_MtP0}

define loopcounter MtLp0 = {$PVM_MtLp0}
}


















# 29 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2



;**** Saturation Pulse Module ****

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/SatPulseDef.mod" 1
;****************************************************************
;
; Copyright (c) 2002-2003
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: SatPulseDef.mod,v 1.1.2.3 2009/02/25 09:35:00 fhen Exp $
;
; All Rights Reserved
;
; SatPulseDef.mod : Declaration of Saturation Pulse subroutines
; call 
; subr SatPulse()
;
;****************************************************************
;   
;    PVM_SatRFPulseArr      :  
;     
;       sp28            DPQQ[12].name : PVM_SatRFPulsePropertyArr[0].Filename
;       sp29            DPQQ[13].name : PVM_SatRFPulsePropertyArr[1].Filename
;       sp30            DPQQ[14].name : PVM_SatRFPulsePropertyArr[2].Filename
;       sp31            DPQQ[15].name : PVM_SatRFPulsePropertyArr[3].Filename
;
;       PVM_SpP0                     :  PVM_SatRFPulseArr[0].PulseLength
;       PVM_SpP1                     :  PVM_SatRFPulseArr[1].PulseLength
;       PVM_SpP2                     :  PVM_SatRFPulseArr[2].PulseLength
;       PVM_SpP3                     :  PVM_SatRFPulseArr[3].PulseLength
;
;       PVM_SpD2                     :  PVM_SatPulseDelay1[0]
;       PVM_SpD6                     :  PVM_SatPulseSpoilTime[0]
;       PVM_SpD10                    :  PVM_SatPulseDelay2[0]
;       PVM_SpD3                     :  PVM_SatPulseSpoilTime[1]
;       PVM_SpD7                     :  PVM_SatPulseDelay1[1]
;       PVM_SpD11                    :  PVM_SatPulseDelay2[1]
;       PVM_SpD4                     :  PVM_SatPulseDelay1[2]
;       PVM_SpD8                     :  PVM_SatPulseSpoilTime[2]
;       PVM_SpD12                    :  PVM_SatPulseDelay2[2]
;       PVM_SpD5                     :  PVM_SatPulseDelay1[3]
;       PVM_SpD9                     :  PVM_SatPulseSpoilTime[3]
;       PVM_SpD13                    :  PVM_SatPulseDelay2[3]
;

if(PVM_SatPulseOnOff == 1)
   {
define list<frequency> modlis7 = {$PVM_SatPulseOffsetHz}

define delay SpD0 = {$PVM_SpD0}
define delay SpD1 = {$PVM_SpD1}
define delay SpD2 = {$PVM_SpD2}
define delay SpD3 = {$PVM_SpD3}
define delay SpD4 = {$PVM_SpD4}
define delay SpD5 = {$PVM_SpD5}
define delay SpD6 = {$PVM_SpD6}
define delay SpD7 = {$PVM_SpD7}
define delay SpD8 = {$PVM_SpD8}
define delay SpD9 = {$PVM_SpD9}
define delay SpD10 = {$PVM_SpD10}
define delay SpD11 = {$PVM_SpD11}
define delay SpD12 = {$PVM_SpD12}
define delay SpD13 = {$PVM_SpD13}
define pulse SpP0 = {$PVM_SpP0}
define pulse SpP1 = {$PVM_SpP1}
define pulse SpP2 = {$PVM_SpP2}
define pulse SpP3 = {$PVM_SpP3}

   }




























































# 34 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2



;*** Saturation Slices Module ***

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/SatSliceDef.mod" 1
;****************************************************************
;
; Copyright (c) 2002-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: SatSliceDef.mod,v 1.2.2.1 2007/07/02 13:01:13 mawi Exp $
;
; All Rights Reserved
;
; SatSlices.mod : Declaration of Saturation Slice subroutine
; call
; subr SatSlices()
;
;****************************************************************
;
; SaturationSlicesPulse :
;
;        sp25              DPQQ[9].name : PVM_SatSlicesPulse.Filename
;        PVM_SatP0                     : PVM_SatSlicesPulse.Length
;
;        
;        PVM_SatD1                     : CONFIG_amplifier_enable
;        PVM_SatD0                     : PVM_RampTime
;        PVM_SatD2                     : PVM_FovSatSpoilTime
;        PVM_SatLp0                    : PVM_FovSatNSlices 
;
;**** Saturation Slice Module ****
if(PVM_FovSatOnOff == 1)
{
define list<frequency> modlis5 = {$PVM_FovSatFL}
define delay SatD0 = {$PVM_SatD0}
define delay SatD1 = {$PVM_SatD1}
define delay SatD2 = {$PVM_SatD2}

define pulse SatP0 = {$PVM_SatP0}

define loopcounter SatLp0 = {$PVM_SatLp0}
}























 
# 39 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2



;**** Black Blood Module ****
# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/BlBloodDef.mod" 1
;****************************************************************
;
; Copyright (c) 2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: BlBloodDef.mod,v 1.1.2.2 2007/07/02 14:26:25 mawi Exp $
;
; All Rights Reserved
;
; BlBloodDef.mod : Declaration of Black blood  subroutine
;
; call
; subr BlBlood(ph0) : Black blood preparation with RF phaselist
;                     ph0
;
;****************************************************************

if(PVM_BlBloodOnOff)
  {
define list<frequency> modlis8 = {$PVM_BlBloodFL}
define delay BlbD0 = {$PVM_BlbD0}
define delay BlbD1 = {$PVM_BlbD1}
define delay BlbD2 = {$PVM_BlbD2}
define delay BlbD3 = {$PVM_BlbD3}

define pulse BlbP0 = {$PVM_BlbP0}
  }
























# 43 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2



;**** Trigger Module ****
define delay TrigD0 = {$PVM_TrigD0}
;**** Trigger Out Module ****
define delay TrigOutD0 = {$PVM_TrigOutD0}

;**** OuterVolumeSuppression **** Solvent Suppression Module ****

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/WsOvsDef.mod" 1
;****************************************************************
;
; Copyright (c) 2005-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: WsOvsDef.mod,v 1.1.2.3 2008/03/19 14:25:28 sako Exp $
;
; All Rights Reserved
;
; WsOvsDef.mod: Declaration of water suppression and Outer 
;               volume suppression subroutines
;
; call 
; subr Ovs(ph0) ;  execution of OVS with ph0 phaselist
;
; subr WsOvs(ph0,ph1) : execution of OVS with ph0 and WS with ph1
;                       phaselist
;****************************************************************

;**** OuterVolumeSuppression ****

if(PVM_OvsOnOff == 1)
{
define list<frequency> Ovslist={$PVM_OvsFrequencyList}
define delay OvsD0 = {$PVM_OvsD0}
define delay OvsD1 = {$PVM_OvsD1}
define pulse OvsP0 = {$PVM_OvsP0}
}





























;*** WaterSuppression Module with OVS ****

if (PVM_WsMode)
{

define list<frequency> Wslist={$PVM_WsOffsetHz}
define pulse WsP0 = {$PVM_WsP0}
define pulse WsP1 = {$PVM_WsP1}
define pulse WsP2 = {$PVM_WsP2}
define delay WsNp0 
"WsNp0 = WsP0"
define delay WsNp1 
"WsNp1 = WsP1"
define delay WsNp2 
"WsNp2 = WsP2"
define list<delay> ChD1={$PVM_ChppgD1}
define list<delay> ChD2={$PVM_ChppgD2}
define list<delay> VpD1={$PVM_VpppgD1}
define list<delay> VpD2={$PVM_VpppgD2}

}
















































































































































































# 53 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;**** Solvent Suppression module and FOV Saturation module ******

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/WsSatDef.mod" 1
;******************************************************************
;
; Copyright (c) 2002-2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: WsSatDef.mod,v 1.1.2.2 2007/07/02 14:26:26 mawi Exp $ 
;
; All Rights Reserved
;
; WsSatDef.mod - Declaration of water suppression and FOV saturation 
;                subroutines
; call
; subr WsSat(ph0) : execution of WS with ph0 phaselist and 
;                   FOV saturation (as passed as argument)    
;      
;*******************************************************************



















































































































































































# 57 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;*********** selective inversion recovery **********

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/SelSliceIrDef.mod" 1
;****************************************************************
;
; Copyright (c) 2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: SelSliceIrDef.mod,v 1.1.2.2 2007/07/02 14:26:25 mawi Exp $
;
; All Rights Reserved
;
; SelSliceIrDef.mod : declaration of slice Selective Inversion 
;                     Recovery subroutine
; call SliceSelIr()
; 
;
;****************************************************************


if(PVM_SelIrOnOff)
  {
define list<frequency> IrFL = {$PVM_SelIrFL} 
define delay IrD0 = {$PVM_SelIrD0}
define delay IrD1 = {$PVM_SelIrD1}
define delay IrD2 = {$PVM_SelIrD2}
define delay IrD3 = {$PVM_SelIrD3}
define delay IrD4 = {$PVM_SelIrD4}

define pulse IrP0 = {$PVM_SelIrP0}

define loopcounter IrL0 = {$PVM_SelIrL0}
  }



















# 61 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;***********Tagging*****************

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/TagDef.mod" 1
;****************************************************************
;
; Copyright (c) 2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: TagDef.mod,v 1.1.2.4 2008/06/05 17:09:32 mawi Exp $
;
; All Rights Reserved
;
; TagDef.mod : Declaration of tagging subroutine
; call
; subr Tagging()
;
;****************************************************************

if(PVM_TaggingOnOff)
{
define list<frequency> taggfreq={$PVM_TaggingFL}

define delay TaggD0 = {$PVM_TaggingD0}
define delay TaggD1 = {$PVM_TaggingD1}
define delay TaggD2 = {$PVM_TaggingD2}
define delay TaggD3 = {$PVM_TaggingD3}
define delay TaggD4 = {$PVM_TaggingD4}
define delay TaggD5 = {$PVM_TaggingD5}

define pulse TaggP0 = {$PVM_TaggingP0}
define loopcounter TaggL0 = {$PVM_TaggingLp0}
}


























































# 65 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2


;*********** Noe *******************

# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/NoeDef.mod" 1
;****************************************************************
;
; Copyright (c) 2007
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; $Id: NoeDef.mod,v 1.1.2.2 2007/07/02 14:26:26 mawi Exp $
;
; All Rights Reserved
;
; NoeDef.mod: Declaration of Nuclear Overhouser Enhancement 
;             subroutine
; call
; subr Noe()
;
;****************************************************************

if(PVM_NoeOnOff == On)
{
define delay NoeD0 = {$PVM_NoeD0}
define delay NoeD1 = {$PVM_NoeD1}
}





















# 69 "/opt/PV5.1/exp/stan/nmr/lists/pp/PrepModulesHead.mod" 2




define loopcounter EvolLp0 = {$PVM_EvolLp0}
define list<delay> EvolD0 = {$PVM_EvolD0}


# 15 "/opt/PV5.1/exp/stan/nmr/lists/pp/PRESS.ppg" 2


define delay de4
"de4=0.00002s-de"

define delay d7m1
"d7m1=d7-1u"
define delay decodur
"decodur=0.00002s-de"
# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/decoacq.mod" 1
;****************************************************************
;
; Copyright (c) 2005
; Bruker BioSpin MRI GmbH 
; D-76275 Ettlingen, Germany
;
; All Rights Reserved
; 
; $Id: decoacq.mod,v 1.3.2.2 2007/07/02 12:51:40 mawi Exp $
; 
; All Rights Reserved
; 
; Declaration of subroutine for decoupling
;
;****************************************************************


if(PVM_DecOnOff == On)
{
define delay DecD0 = {$PVM_DecD0}
define delay DecD1 = {$PVM_DecD1}
}


































# 24 "/opt/PV5.1/exp/stan/nmr/lists/pp/PRESS.ppg" 2

define loopcounter lds={$NDummyScans}
define loopcounter lnav

preset off

fq1b receive				     	     \n if (CONFIG_instrument_type != Avance_I)           \n {                                                 \n dccorr                                         \n }                         \n if (CONFIG_preemp_type == GREAT_60)               \n {                                                 \n if (CONFIG_instrument_type != Avance_III)      \n {                                              \n 500m setnmr0|34|33|32                          \n }                                              \n else                                           \n {                                              \n 200u setnmr0|34|33|32                          \n }                                              \n }                                                 \n if (CONFIG_preemp_type == DPP_with_SW_Blanking)   \n {                                                 \n 10u ctrlgrad 0                                 \n 10u grad{(0)|(0)|(0) }			     \n 200u setnmr0|34|33|32                          \n }

;-------D/P-----GRAD----------------------------RF/ACQ------------

        1u      rpp1
        1u      rpp2
        1u      rpp3
        1u	rpp31

start,	4u					
av,	d1				fq8b:f1
;---------Triggered data -----------------------------------------
# 1 "/opt/PV5.1/exp/stan/nmr/lists/pp/TriggerPerSlice.mod" 1
;****************************************************************
;
; Copyright (c) 1998-2003
; Bruker BioSpin MRI GmbH
; D-76275 Ettlingen, Germany
;
; All Rights Reserved
;
; TriggerPerSlice.mod - Trigger Module
;
;****************************************************************
;
;     PVM_TrigD0               --> PVM_EcgTriggerModuleTime = ACQ_trigger_delay
;
if (PVM_TriggerMode == per_Slice)
{
if (ACQ_trigger_enable == 1)
{
  10u   setnmr3|6
if (CONFIG_instrument_type == Avance_III)
{
  10u   trignl1
  10u   trigpe3
}
else
{
  10u   trigpl1
}
  10u   setnmr3^6 
  TrigD0
}
}
# 42 "/opt/PV5.1/exp/stan/nmr/lists/pp/PRESS.ppg" 2

		
;---------noe  module-----------------------------------------
;EXEC_begin Noe line 1558 (45) Noe()
 
if(PVM_NoeOnOff == On)
{
  if (PVM_NoeMode == Continuous_Wave_Noe)
     {  
        3u pl1:f2
        NoeD0  cw:f2
        1u do:f2
        NoeD1
     }
  if (PVM_NoeMode == Composite_Pulse_Noe)
     {  
        3u pl1:f2
        NoeD0 cpds1:f2
        1u do:f2
        NoeD1
     }
}
 
;EXEC_end   Noe line 1558 (45) Noe()
;---------ws & ovs module-----------------------------------------
;EXEC_begin WsOvs line 1560 (47) WsOvs(phase ph0, phase ph0)
 
;EXEC_begin WsOvsMain line 1016 (0) WsOvsMain(phase ph0, phase ph0, any PVM_OvsOnOff)
 

;-------------------------------------------------------------------------------
; NO_SUPPRESSION
;-------------------------------------------------------------------------------

;WS_Mode == NO_SUPPRESSION
if ( PVM_WsMode == 0 ) {

if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 862 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 862 (0) Ovs(phase ph0)
;EXEC_begin Ovs line 863 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 863 (0) Ovs(phase ph0)
;EXEC_begin Ovs line 864 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 864 (0) Ovs(phase ph0)
}

}


;-------------------------------------------------------------------------------
; CHESS scheme
;-------------------------------------------------------------------------------
if ( PVM_WsMode == 1 ) {
0.1u 	Wslist[0]:f1
;first pulse
if ( PVM_WsOnOff == On ) {
	(WsP0:sp4 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp0
}
	ChD1[0] grad{ (PVM_ChTrim[0]) | (PVM_ChTrim[1]) | (PVM_ChTrim[2]) }
	ChD2[0] groff
if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 885 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 885 (0) Ovs(phase ph0)
0.1u 	Wslist[0]:f1
}

;second pulse
if ( PVM_WsOnOff == On ) {
	(WsP1:sp5 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp1
}
	ChD1[1] grad{ (PVM_ChTrim[3]) | (PVM_ChTrim[4]) | (PVM_ChTrim[5]) }
	ChD2[1] groff
if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 899 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 899 (0) Ovs(phase ph0)
0.1u 	Wslist[0]:f1
}

;third pulse
if ( PVM_WsOnOff == On ) {
	(WsP2:sp6 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
        WsNp2	
}
	ChD1[2] grad{ (PVM_ChTrim[6]) | (PVM_ChTrim[7]) | (PVM_ChTrim[8]) }
	ChD2[2] groff
if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 913 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 913 (0) Ovs(phase ph0)
}

};end of CHESS


;-------------------------------------------------------------------------------
; VAPOR scheme
;-------------------------------------------------------------------------------
if ( PVM_WsMode == 2 ) {
0.1u 	Wslist[0]:f1
;first pulse
if ( PVM_WsOnOff == On ) {
	(WsP0:sp4 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp0
}
	VpD1[0] grad{ (PVM_VpTrim[0]) | (PVM_VpTrim[1]) | (PVM_VpTrim[2]) }
	VpD2[0] groff


;second pulse
if ( PVM_WsOnOff == On ) {
	(WsP0:sp4 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
        WsNp0	
}
	VpD1[1] grad{ (PVM_VpTrim[3]) | (PVM_VpTrim[4]) | (PVM_VpTrim[5]) }
	VpD2[1] groff


;third pulse
if ( PVM_WsOnOff == On ) {
	(WsP1:sp5 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp1	
}
	VpD1[2] grad{ (PVM_VpTrim[6]) | (PVM_VpTrim[7]) | (PVM_VpTrim[8]) }
	VpD2[2] groff

;fourth pulse
if ( PVM_WsOnOff == On ) {
	(WsP0:sp4 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp0
}

if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 965 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 965 (0) Ovs(phase ph0)
}
	VpD1[3] grad{ (PVM_VpTrim[9]) | (PVM_VpTrim[10]) | (PVM_VpTrim[11]) }
	VpD2[3] groff Wslist[0]:f1


;5.th pulse
if ( PVM_WsOnOff == On ) {
(	WsP1:sp5 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp1
}
	VpD1[4] grad{ (PVM_VpTrim[12]) | (PVM_VpTrim[13]) | (PVM_VpTrim[14]) }
	VpD2[4] groff
if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 981 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 981 (0) Ovs(phase ph0)
0.1u 	Wslist[0]:f1
}


;6.th pulse
if ( PVM_WsOnOff == On ) {
	(WsP0:sp4 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp0	
}
	VpD1[5] grad{ (PVM_VpTrim[15]) | (PVM_VpTrim[16]) | (PVM_VpTrim[17]) }
	VpD2[5] groff


;7.th pulse
if ( PVM_WsOnOff == On ) {
	(WsP1:sp5 ph0):f1
}
if ( PVM_WsOnOff == Off ) {
	WsNp1
}
	VpD1[6] grad{ (PVM_VpTrim[18]) | (PVM_VpTrim[19]) | (PVM_VpTrim[20]) }
	VpD2[6] groff
if ( PVM_OvsOnOff == On ) {
;EXEC_begin Ovs line 1007 (0) Ovs(phase ph0)
 
;-------------------------------------------------------------------------------
;	delays		grads			rf/rec		comments
;-------------------------------------------------------------------------------
	;pulses 1 + 2	
	OvsD0 	grad{  (PVM_OvsTrim0) | (0.0) | (0.0) }	Ovslist[0]:f1
	(OvsP0:sp7 ph0):f1	
	10u					Ovslist[1]:f1
	(OvsP0:sp7 ph0):f1										
	OvsD1	grad{  (PVM_OvsTrim1) | (0.0) | (0.0) }					
	
	;pulses 3 + 4
	OvsD0 	grad{  (0.0) | (PVM_OvsTrim0) | (0.0) }	Ovslist[2]:f1		
	(OvsP0:sp7 ph0):f1	
	10u 					Ovslist[3]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (PVM_OvsTrim2) | (0.0) }
			
	;pulses 5 + 6
	OvsD0 	grad{  (0.0) | (0.0) | (PVM_OvsTrim0) }	Ovslist[4]:f1			
	(OvsP0:sp7 ph0):f1						
	10u 					Ovslist[5]:f1
	(OvsP0:sp7 ph0):f1
	OvsD1	grad{  (0.0) | (0.0) | (PVM_OvsTrim3) }
	OvsD0 	groff
 
;EXEC_end   Ovs line 1007 (0) Ovs(phase ph0)
}

};end vapor
 ;end subr WsOvsMain
;EXEC_end   WsOvsMain line 1016 (0) WsOvsMain(phase ph0, phase ph0, any PVM_OvsOnOff)
 
;EXEC_end   WsOvs line 1560 (47) WsOvs(phase ph0, phase ph0)

;---------localisation  module------------------------------------
	1u
	d4	grad{  (t1) | (0.0) | (0.0) } 	fq1:f1
	d6					gatepulse 1
	(p1:sp1 ph1):f1
	d6
        "lnav=0"
	d7m1	groff			
nav,	0.5u
        0.5u
        if "lnav > 0"  {
	 if(PVM_ppgFlag4 == Yes) 
        {
	d4	grad{  (t1) | (0.0) | (0.0) } 	fq1:f1
	d6					gatepulse 1
	(p1:sp0 ph1):f1
	d6
	d7m1	groff	
	}
	1u
	}
	d8 grad{ (t4)  | (t6) | (t7) }
	d4	grad{ (0.0) |  (t2) | (0.0) }   fq1:f1
	d6					gatepulse 1
	(p2:sp2 ph2):f1
	d6
	d8	grad{  (t5) |  (t6) |  (t7) }
	d9	groff

	;pulse adjustments:
	if ( PVM_ppgFlag3 == Yes ) {
	d12	grad{ (t11) | (t12) | (t13) }
	d4	groff	
	}
	d10	grad{  (t8) |  (t9) | (t10) }	fq1:f1
	d4	grad{ (0.0) | (0.0) |  (t3) }
	d6					gatepulse 1
	(p3:sp3 ph3):f1
	d6
	d10	grad{  (t8) |  (t9) | (t10) }
	d11	groff				
	
;---------data acquisition--------------------------------------------	
	;pulse adjustments:
	if ( PVM_ppgFlag3 == Yes ) 
	{
	  d4	grad{ (t14) | (t15) | (t16) }	
	  de4
	   				        rdepa						 \n deparx     adc ph31  syrec fqatofqb:f1 \n derxadc     ph0:r  			 \n deadc      
	  aqq					cpdngs30:f1	
	}
	else 
	{
;EXEC_begin decoup line 1615 (102) decoup(delay decodur, phase ph31, phase ph0)
 
  if (PVM_DecOnOff == Off)
     {
     3u
     decodur
     rdepa						 \n deparx     adc ph31  syrec fqatofqb:f1 \n derxadc     ph0:r  			 \n deadc      
     4u        cpdngs30:f1
     aqq
     }
  if (PVM_DecOnOff == On)
     {
     if (PVM_DecMode == Continuous_Wave)
     {
     3u pl2:f2
     decodur
     rdepa						 \n deparx     adc ph31  syrec fqatofqb:f1 \n derxadc     ph0:r  			 \n deadc      
     4u        cpdngs30:f1
     DecD0 cw:f2
     DecD1 do:f2
     }
     if (PVM_DecMode == Composite_Pulse)
     {
     3u  pl2:f2
     decodur
     rdepa						 \n deparx     adc ph31  syrec fqatofqb:f1 \n derxadc     ph0:r  			 \n deadc      
     4u        cpdngs30:f1
     DecD0 cpd2:f2
     DecD1 do:f2
     }
     }
 
;EXEC_end   decoup line 1615 (102) decoup(delay decodur, phase ph31, phase ph0)
        }
        3m groff
	if(OPT_RFLOnOff == On)
        {
	    1m reload B0
	}
	else
	{
	    1m
	}
        "lnav = 1"
	1m					eoscnp	
;---------navigator loop ---------------------------------------------
	lo to nav times l1


;---------dummy scans ------------------------------------------------
	"lds = lds - 1"		
	if "lds>=0" goto start	

;---------averaging & phase cycling-----------------------------------
	if ( ACQ_scan_type == Scan_Experiment ) {
	1u					ipp1
	1u					ipp2
	1u 					ipp3
	1u 					ipp31
	}
	lo to start times NA	
	1u					rpp1
	1u					rpp2
	1u 					rpp3
	1u 					rpp31
        
        lo to av times NR
	if (ACQ_scan_type != Scan_Experiment) \n{ \n goto av \n}
exit


ph0 = 0
ph1 = {0 0 0 0 0 0 0 0  0 0 0 0 0 0 0 0}^2^1^3
ph2 = {0 0 1 1 0 0 1 1  2 2 3 3 2 2 3 3}^2^1^3
ph3 = {0 2 0 2 1 3 1 3  0 2 0 2 1 3 1 3}^2^1^3
ph31= {0 0 2 2 2 2 0 0  0 0 2 2 2 2 0 0}^2^1^3





